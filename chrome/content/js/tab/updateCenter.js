//  Origianl Author: Kennyluck
// Open Source MIT licence dig.csail.mit.edu

function updateCenter(kb){
    
    //require webdav
    var sparqlService = new tabulator.rdf.sparqlUpdate(kb);
    return {
    
    // Function to tell whether a document is editable from the HTTP headers when it was fetched.
    editMethod: function editMethod(doc){ //extends sparql.editable,
        /* A "document" can be editable: Only documents can be editable, not cars or people.
        ** In N3:
        ** {?doc link:request ?request. ?request link:response ?response.
        **      ?request httph:ms-author-via ?protocol}
        **                              => {?doc :editable true}.
        */
        if (doc.uri == undefined) {
            // dump("editMethod: Weird -- called with: "+doc+"\n");
            return false;  // Not a symbol  - some other provenance
        }
        if (doc.uri.indexOf('#') >= 0) throw "Document URI for writing to can't have a # in it:"+doc;
        var request = kb.any(undefined, tabulator.ns.link("requestedURI"), doc.uri);
        if (request !== undefined) {
            var response =  kb.any(request, tabulator.ns.link("response"));
            if (!response) {
                // dump("editMethod: No recorded HTTP GET response for document "+doc+" !\n")
                return null; // throw "No recorded HTTP GET response for document: "+doc; //could be still in process
            }
            var method = kb.any(response, tabulator.ns.httph("ms-author-via"));
            // dump("editMethod: Method for document "+doc+" is :"+method+"\n"); //@@
            return method
        } else {
            if (doc.sameTerm(kb.fetcher.appNode)) return false; //statements generated by the tabulator
            try{var protocol = Util.uri.protocol(doc.uri);}catch(e){return false;/*alert(e+doc+kb.bnode(0))*/};
            if (protocol == 'http' || protocol == 'https') //statements via HTTP but not chrome: or others
                throw "there is no 'request' (yet?) for this HTTP document: "+doc.uri+this.editMethod.caller;
            if (protocol == 'file')
                return kb.literal('LOCALFILE');
        }
        return false;        
    },

    // This high-level function should be all you need.
    // It updates the local store iff the web is changed successfully. 
    //
    //  - doc is the document on the web in which the changes will be made
    //  - deletions, insertions may be single statements or lists or formulae.
    //  - callback is called as callback(uri, success, errorbody)
    //
    update: function(doc, deletions, insertions, callback) {
        var ds =  deletions instanceof $rdf.IndexedFormula ? deletions.statements
                     : deletions instanceof Array ? deletions : [ deletions ];
        var is =  insertions instanceof $rdf.IndexedFormula ? insertions.statements
                     : insertions instanceof Array ? insertions : [ deletions ];
        var protocol = this.editMethod(doc);
        if (!protocol) throw "Can't make changes in uneditable "+doc;
        if (protocol.indexOf('SPARQL') >=0) {
        
        } else if (protocol.indexOf('WEBDAV') >=0) {
        
        } else throw "Unhandled edit method: '"+protocol+"' for "+doc;
    },

    
    //!! sts = [statement, new object]
    update_statement: function update_statement(st, callback, newObject) {
        this._mutate_statement(st, callback, 'UPDATE', newObject);
    },
    insert_statement: function insert_statement(st, callback) {
        this._mutate_statement(st, callback, 'INSERT');
    },    
    delete_statement: function delete_statement(st, callback) {
        this._mutate_statement(st, callback, 'DELETE');
    },
    _mutate_statement: function mutate_statement(st, callback, mode, newObject){
        dump("mutate_statement: st = {"+st+"}, mode="+mode+"\n")
        var doc = st.why;
        var targetURI = doc.uri;
        var protocol = this.editMethod(doc).value;
        switch (protocol){
            case 'SPARQL': //cool!
                try{
                    if (mode == 'INSERT'){
                        sparqlService.insert_statement(st, callback);
                    }else if (mode == 'DELETE'){
                        sparqlService.delete_statement(st, callback);
                    }else if (mode == 'UPDATE'){
                        var temp = sparqlService.update_statement(st);
                        temp.set_object(newObject, callback);
                    }
                }catch(e){throw 'Error performing SPARQL operation in _mutateStatement: '+e;}
                break;
            // Updating the whole document isn't as slick but often WEBDAV will be all that is available.
            case 'DAV':
            case 'LOCALFILE':
                try{
                    var documentString;
                    var request = kb.any(doc, tabulator.ns.link("request"));
                    if (!request) throw "No record of our HTTP GET request for document: "+doc; //should not happen
                    var response =  kb.any(request, tabulator.ns.link("response"));
                    if (!response)  return null; // throw "No record HTTP GET response for document: "+doc;

                    //prepare contents
                    var sts = kb.statementsMatching(undefined, undefined, undefined, doc);
                    var newSts = [];//it's necessary to make a copy to avoid
                                    //side-effects, this is tricky
                    for (var i=0;i<sts.length;i++)
                        newSts.push(sts[i]);                                     
                    if (mode == 'INSERT'){
                        newSts.push(st);
                    }else if (mode == 'DELETE'){
                        RDFArrayRemove(newSts, st);
                    }else if (mode == 'UPDATE'){
                        newSts.push(new RDFStatement(st.subject,st.predicate,newObject,st.why));
                        RDFArrayRemove(newSts, st);
                    }else{
                        throw "unknow mode @ updateCenter::_mutate_statement";
                    }
                    
                    //serialization 
                    // @@ slow with current store!
                    var sz = Serializer();
                    sz.suggestNamespaces(kb.namespaces);
                    sz.setBase(doc.uri);//?? beware of this                    
                    var content_type = kb.the(response, tabulator.ns.httph("content-type")).value;            
                    switch(content_type){
                        case 'application/rdf+xml': 
                            documentString = sz.statementsToXML(newSts);
                            break;
                        case 'text/rdf+n3': // Legacy
                        case 'text/n3':
                        case 'text/turtle':
                        case 'application/x-turtle': // Legacy
                        case 'application/n3': // Legacy
                            documentString = sz.statementsToN3(newSts);
                            break;
                        default:
                            throw "Content-type "+content_type +" not supported for data write";                                                                            
                    }
                    
                    //sending...
                    if (protocol == 'DAV'){
                        var candidateTarget = kb.the(response, tabulator.ns.httph("content-location"));
                        if (candidateTarget) targetURI = Util.uri.join(candidateTarget.value, targetURI);
                        //webdav.client.prototype.PUT(docURI, documentString, callback);
                        //I can't use this...
                        var xhr = Util.XMLHTTPFactory();
                        xhr.onreadystatechange = function (){
                            if (xhr.readyState == 4){
                                //formula from sparqlUpdate.js, what about redirects?
                                var success = (!xhr.status || (xhr.status >= 200 && xhr.status < 300));
                                callback(doc.uri/*this argument seems to be useless anyway*/
                                          ,success,xhr.responseText);
                            }
                        };
                        xhr.open('PUT', targetURI, true);
                        //assume the server does PUT content-negotiation.
                        xhr.setRequestHeader('Content-type', content_type);//OK?
                        xhr.send(documentString);
                        tabulator.log.info("sending "+sts+"["+documentString+"] to +"+targetURI);
                    }else{
                        
                    }                 
                }catch(e){throw "mutate_statement: Error in "+mode+" for statement: "+st+": "+e;}
                break;

            default:
                //I suggest we should provide a space from the wiki to the user, as I think
                //any opinion is valuable -- kenny. But for now:            
                throw ("Unsupported protocol (or no protocol) for this document: "+docURI);                                 
            }
        }        
    };//end of return
    
}
